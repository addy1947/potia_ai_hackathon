"""
Vulnerability Scanner Tool for Gemini AI Agent
Scans dependencies for known security vulnerabilities
"""

import requests
import json
from typing import Dict, List, Optional, Any
from packaging import version
from ..utils.tool_registry import Tool
from datetime import datetime
import tempfile
import shutil
import os
import subprocess


class VulnerabilityScanner(Tool):
    """Tool for scanning dependencies for security vulnerabilities"""

    def __init__(self, config: Dict[str, Any]):
        super().__init__(
            name="vulnerability_scanner",
            description="Scan dependencies for security vulnerabilities using Semgrep and CVE databases",
        )
        self.config = config
        # Add required fields for compatibility
        self.id = "vulnerability_scanner"
        self.output_schema = {
            "type": "object",
            "properties": {
                "success": {"type": "boolean"},
                "findings": {"type": "array"},
                "error": {"type": "string"},
            },
        }
        self.semgrep_token = os.getenv("SEMGREP_API_TOKEN")

    def execute(self, **kwargs) -> Any:
        """Execute the vulnerability scanner tool"""
        action = kwargs.get("action", "scan_with_semgrep")

        if action == "scan_with_semgrep":
            return self.scan_with_semgrep(
                kwargs.get("file_path"), kwargs.get("file_content")
            )
        elif action == "check_cve_database":
            return self.check_cve_database(
                kwargs.get("package_name"), kwargs.get("version")
            )
        elif action == "scan_dependencies":
            return self.scan_dependencies(
                kwargs.get("dependencies"), kwargs.get("package_manager")
            )
        elif action == "get_vulnerability_summary":
            return self.get_vulnerability_summary(kwargs.get("scan_results"))
        else:
            return {
                "error": f"Unknown action: {action}. Supported actions: scan_with_semgrep, check_cve_database, scan_dependencies, get_vulnerability_summary"
            }

    def scan_with_semgrep(
        self, file_path: str, file_content: str = None
    ) -> Dict[str, Any]:
        """
        Scan a file or content with Semgrep for security issues

        Args:
            file_path: Path to the file (used for context)
            file_content: Optional file content (if not provided, reads from file_path)

        Returns:
            Dictionary containing scan results
        """
        try:
            # Create temporary file if content is provided
            temp_file = None
            scan_path = file_path

            if file_content:
                temp_file = tempfile.NamedTemporaryFile(
                    mode="w", suffix=os.path.splitext(file_path)[1], delete=False
                )
                temp_file.write(file_content)
                temp_file.close()
                scan_path = temp_file.name

            # Build Semgrep command
            cmd = [
                "semgrep",
                "--config=auto",  # Use automatic rule selection
                "--json",  # Output in JSON format
                "--verbose",
                scan_path,
            ]

            # Add token if available for additional rules
            if self.semgrep_token:
                cmd.extend(["--config", "p/security-audit"])
                cmd.extend(["--config", "p/owasp-top-ten"])

            # Run Semgrep
            result = subprocess.run(
                cmd, capture_output=True, text=True, timeout=300  # 5 minute timeout
            )

            # Clean up temp file
            if temp_file and os.path.exists(temp_file.name):
                os.unlink(temp_file.name)

            if result.returncode == 0:
                findings = json.loads(result.stdout)
                return {
                    "success": True,
                    "findings": findings.get("results", []),
                    "errors": findings.get("errors", []),
                    "total_findings": len(findings.get("results", [])),
                }
            else:
                return {
                    "success": False,
                    "error": result.stderr,
                    "stdout": result.stdout,
                }

        except subprocess.TimeoutExpired:
            if temp_file and os.path.exists(temp_file.name):
                os.unlink(temp_file.name)
            return {"success": False, "error": "Semgrep scan timed out after 5 minutes"}
        except Exception as e:
            if temp_file and os.path.exists(temp_file.name):
                os.unlink(temp_file.name)
            return {"success": False, "error": f"Semgrep scan failed: {str(e)}"}

    def check_cve_database(self, package_name: str, version: str) -> Dict[str, Any]:
        """
        Check CVE database for known vulnerabilities in a specific package version

        Args:
            package_name: Name of the package
            version: Version of the package

        Returns:
            Dictionary containing CVE information
        """
        try:
            # Use OSV.dev API for comprehensive vulnerability data
            osv_url = "https://api.osv.dev/v1/query"

            payload = {"package": {"name": package_name}, "version": version}

            response = requests.post(osv_url, json=payload, timeout=30)

            if response.status_code == 200:
                data = response.json()
                vulnerabilities = data.get("vulns", [])

                # Process vulnerabilities
                processed_vulns = []
                for vuln in vulnerabilities:
                    processed_vuln = {
                        "id": vuln.get("id"),
                        "summary": vuln.get("summary"),
                        "severity": self._extract_severity(vuln),
                        "published": vuln.get("published"),
                        "modified": vuln.get("modified"),
                        "references": [
                            ref.get("url") for ref in vuln.get("references", [])
                        ],
                        "affected_versions": self._extract_affected_versions(vuln),
                        "fixed_versions": self._extract_fixed_versions(vuln),
                    }
                    processed_vulns.append(processed_vuln)

                return {
                    "success": True,
                    "package": package_name,
                    "version": version,
                    "vulnerabilities": processed_vulns,
                    "vulnerability_count": len(processed_vulns),
                }
            else:
                return {
                    "success": False,
                    "error": f"CVE API returned status {response.status_code}",
                }

        except Exception as e:
            return {"success": False, "error": f"CVE lookup failed: {str(e)}"}

    def _extract_severity(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        """Extract severity information from vulnerability data"""
        severity_info = {"level": "unknown", "score": None, "vector": None}

        # Check for CVSS scores
        if "severity" in vuln:
            for severity in vuln["severity"]:
                if severity.get("type") == "CVSS_V3":
                    severity_info["score"] = severity.get("score")
                    severity_info["vector"] = severity.get("vector")

                    # Determine level based on score
                    score = severity.get("score", 0)
                    if score >= 9.0:
                        severity_info["level"] = "critical"
                    elif score >= 7.0:
                        severity_info["level"] = "high"
                    elif score >= 4.0:
                        severity_info["level"] = "medium"
                    else:
                        severity_info["level"] = "low"
                    break

        return severity_info

    def _extract_affected_versions(self, vuln: Dict[str, Any]) -> List[str]:
        """Extract affected version ranges from vulnerability data"""
        affected = []

        for affect in vuln.get("affected", []):
            if "versions" in affect:
                affected.extend(affect["versions"])
            elif "ranges" in affect:
                for range_info in affect["ranges"]:
                    if "events" in range_info:
                        for event in range_info["events"]:
                            if "introduced" in event:
                                affected.append(f">= {event['introduced']}")
                            elif "fixed" in event:
                                affected.append(f"< {event['fixed']}")

        return affected

    def _extract_fixed_versions(self, vuln: Dict[str, Any]) -> List[str]:
        """Extract fixed versions from vulnerability data"""
        fixed = []

        for affect in vuln.get("affected", []):
            if "ranges" in affect:
                for range_info in affect["ranges"]:
                    if "events" in range_info:
                        for event in range_info["events"]:
                            if "fixed" in event:
                                fixed.append(event["fixed"])

        return list(set(fixed))  # Remove duplicates

    def scan_dependency_list(
        self, dependencies: Dict[str, str], package_manager: str
    ) -> Dict[str, Any]:
        """
        Scan a list of dependencies for vulnerabilities

        Args:
            dependencies: Dictionary of {package_name: version}
            package_manager: Type of package manager (npm, pip, maven, etc.)

        Returns:
            Comprehensive vulnerability report
        """
        results = {
            "package_manager": package_manager,
            "scanned_packages": 0,
            "vulnerable_packages": 0,
            "total_vulnerabilities": 0,
            "critical_vulnerabilities": 0,
            "high_vulnerabilities": 0,
            "medium_vulnerabilities": 0,
            "low_vulnerabilities": 0,
            "packages": {},
        }

        for package_name, version in dependencies.items():
            results["scanned_packages"] += 1

            # Normalize package name for different package managers
            normalized_name = self._normalize_package_name(
                package_name, package_manager
            )

            # Check for vulnerabilities
            vuln_result = self.check_cve_database(normalized_name, version)

            if vuln_result["success"] and vuln_result["vulnerabilities"]:
                results["vulnerable_packages"] += 1
                results["total_vulnerabilities"] += len(vuln_result["vulnerabilities"])

                # Count severity levels
                for vuln in vuln_result["vulnerabilities"]:
                    severity = vuln["severity"]["level"]
                    if severity == "critical":
                        results["critical_vulnerabilities"] += 1
                    elif severity == "high":
                        results["high_vulnerabilities"] += 1
                    elif severity == "medium":
                        results["medium_vulnerabilities"] += 1
                    elif severity == "low":
                        results["low_vulnerabilities"] += 1

            results["packages"][package_name] = {
                "version": version,
                "vulnerabilities": vuln_result.get("vulnerabilities", []),
                "vulnerability_count": len(vuln_result.get("vulnerabilities", [])),
                "scan_success": vuln_result["success"],
                "scan_error": vuln_result.get("error"),
            }

        return results

    def _normalize_package_name(self, package_name: str, package_manager: str) -> str:
        """Normalize package name for different package managers"""
        if package_manager == "npm":
            # NPM packages are usually already normalized
            return package_name
        elif package_manager == "pip":
            # Python packages: convert underscores to hyphens, lowercase
            return package_name.replace("_", "-").lower()
        elif package_manager == "maven":
            # Maven: format as groupId:artifactId
            return package_name
        else:
            return package_name

    def generate_vulnerability_report(
        self, scan_results: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Generate a formatted vulnerability report
        """
        report = {
            "scan_timestamp": datetime.now().isoformat(),
            "summary": {
                "total_packages": scan_results["scanned_packages"],
                "vulnerable_packages": scan_results["vulnerable_packages"],
                "total_vulnerabilities": scan_results["total_vulnerabilities"],
                "severity_breakdown": {
                    "critical": scan_results["critical_vulnerabilities"],
                    "high": scan_results["high_vulnerabilities"],
                    "medium": scan_results["medium_vulnerabilities"],
                    "low": scan_results["low_vulnerabilities"],
                },
            },
            "recommendations": self._generate_recommendations(scan_results),
            "detailed_findings": scan_results["packages"],
        }

        return report

    def _generate_recommendations(self, scan_results: Dict[str, Any]) -> List[str]:
        """Generate actionable recommendations based on scan results"""
        recommendations = []

        if scan_results["critical_vulnerabilities"] > 0:
            recommendations.append(
                f"URGENT: {scan_results['critical_vulnerabilities']} critical vulnerabilities found. "
                "Immediate action required - consider emergency patching."
            )

        if scan_results["high_vulnerabilities"] > 0:
            recommendations.append(
                f"HIGH PRIORITY: {scan_results['high_vulnerabilities']} high-severity vulnerabilities found. "
                "Schedule updates within 7 days."
            )

        if scan_results["medium_vulnerabilities"] > 0:
            recommendations.append(
                f"MEDIUM PRIORITY: {scan_results['medium_vulnerabilities']} medium-severity vulnerabilities found. "
                "Include in next regular update cycle."
            )

        # Check for packages with multiple vulnerabilities
        multi_vuln_packages = [
            pkg
            for pkg, data in scan_results["packages"].items()
            if data["vulnerability_count"] > 1
        ]

        if multi_vuln_packages:
            recommendations.append(
                f"Multiple vulnerabilities in: {', '.join(multi_vuln_packages[:5])}. "
                "Prioritize these packages for updates."
            )

        if scan_results["vulnerable_packages"] == 0:
            recommendations.append("No vulnerabilities found. Dependencies are secure.")

        return recommendations

    def run(self, **kwargs) -> Dict[str, Any]:
        """
        Main run method for the vulnerability scanner tool
        """
        operation = kwargs.get("operation")

        if operation == "scan_file":
            return self.scan_with_semgrep(
                kwargs["file_path"], kwargs.get("file_content")
            )
        elif operation == "check_package":
            return self.check_cve_database(kwargs["package_name"], kwargs["version"])
        elif operation == "scan_dependencies":
            return self.scan_dependency_list(
                kwargs["dependencies"], kwargs["package_manager"]
            )
        elif operation == "generate_report":
            return self.generate_vulnerability_report(kwargs["scan_results"])
        else:
            return {"error": f"Unknown operation: {operation}"}
